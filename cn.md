# RGL: 一个现代化的 C++ 渲染框架

RGL 是一个从零开始构建的高性能、现代化C++渲染框架。它以**实体组件系统 (ECS)** 为核心架构，利用现代C++20/23特性和数据驱动的设计理念，旨在打造一个灵活而强大的图形引擎。这个项目始于一个学习目标，现已演变成一个能够处理复杂场景、先进渲染技术和精细资产管线的健壮框架。

## ✨ 核心特性

-   **现代化的图形API (OpenGL 4.6):** 充分利用现代OpenGL特性，尤其是**直接状态访问 (Direct State Access, DSA)**，以减少API状态切换，提升渲染效率。
-   **ECS驱动的架构:** 基于业界领先的 **EnTT** 库构建。场景中的所有对象都作为实体进行管理，其行为和数据由不同的组件定义，从而实现了清晰、解耦且对缓存极为友好的代码结构。
-   **数据驱动的场景图:** 使用 **EnTT的关系 (Relationship)** 组件实现了一个逻辑上的场景图，取代了传统的基于指针的树形结构。这种方法使得场景的遍历和变换更新更加高效。
-   **先进的渲染管线:** 拥有一个设计精巧的渲染队列系统，能自动将物体根据材质属性（不透明、半透明）和渲染方式（实例化）分类。通过对半透明物体进行**由远及近的排序**，正确地处理了Alpha混合。
-   **健壮的资产管线:** 集成了强大的 **Assimp** 库，支持加载复杂的3D模型及其材质。框架内置了完善的纹理缓存，能够处理节点的层级关系、合并网格，并解析PBR材质属性。
-   **高性能实例化渲染:** 支持硬件加速的实例化渲染，能够以极低的CPU开销绘制成千上万个重复的物体（例如草地、岩石等）。
-   **RAII风格的C++封装:** 为OpenGL的核心对象（如 `VAO`, `VBO`, `Shader`, `Texture`）提供了简洁、安全且现代化的C++封装，确保了资源的正确管理和释放。

## 📂 项目结构

-   `app`: 存放主应用逻辑，并提供了一个灵活的 `Renderer` 接口，用于实现各种图形效果和Demo。
-   `render_core`: 框架的核心。包含了所有渲染相关的组件，包括ECS的实现 (`EnTT`)、OpenGL的封装、着色器管理、资产导入器 (`Assimp`) 以及渲染管线等。
-   `practices`: 通过具体的示例来展示框架各项功能的使用方法（例如UBO测试、模型实例化渲染等）。

## 🚀 依赖与构建

本项目使用 vcpkg 的清单模式 (manifest mode) 管理依赖。如果你正确安装了 vcpkg，所有依赖项将被自动下载和安装。

### 依赖库

-   SDL3
-   EnTT
-   GLM
-   Glad
-   spdlog
-   Assimp
-   stb_image
-   以及更多... (由 `vcpkg.json` 文件管理)

### 构建指南

1.  确保已安装 **Visual Studio 2022** 和最新版的 **vcpkg**。
2.  克隆本仓库。
3.  使用 Visual Studio 打开仓库文件夹。
4.  如果你没有设置 `VCPKG_ROOT` 系统环境变量，可能需要编辑项目根目录下的 `CMakeSettings.json` 文件，将其中的 `cmakeToolchain` 路径指向你的 `vcpkg.cmake` 工具链文件。
5.  使用快捷键 `Ctrl + Shift + B` 构建项目。

## 🗺️ 未来规划

RGL 是一个仍在积极演进中的项目。以下是我为之制定的宏伟蓝图：

1.  **模型尺寸自动适配:** 为所有导入的模型计算AABB包围盒（Axis-Aligned Bounding Box），并根据包围盒自动缩放和居中模型。再也不想遇到导入模型后因尺寸或位置问题而看不见任何东西的窘境了。
2.  **引入Bindless Textures:** 全面转向 `glGetTextureHandleARB`，彻底摆脱 `texture unit` 这一历史遗留设计的限制。让着色器中可用的纹理数量接近无限！
3.  **集成SPIR-V着色器管线:** 引入 **SPIR-V** 和 **SPIRV-Cross**，彻底告别在GLSL中硬编码 `layout(location = ...)` 和 `uniform` 变量名的时代。这将实现真正的着色器反射，构建更健壮、与后端无关的材质系统。
4.  **统一的资产管理系统:** 利用 **Boost.Serialization** 创建一套完整的资产系统。该系统能将处理好的模型、网格、AABB包围盒、SPIR-V着色器等序列化为自定义的二进制格式，以实现闪电般的加载速度。
5.  **探索高级渲染主题:** 深入研究**基于物理的渲染 (PBR)**，实现基于图像的照明 (IBL)、动态阴影、以及其他高级光照和后处理效果。
6.  **实现Vulkan后端:** 对渲染API进行抽象，在OpenGL之外支持 **Vulkan** 后端，实现一个真正的跨API图形框架的最初设想。
7.  **(终极目标) 实现Multi-Draw Indirect (MDI):** 利用 `glMultiDrawElementsIndirect` 等技术实现GPU驱动的渲染管线，将渲染逻辑尽可能地移交给GPU处理，从而在处理海量场景时达到极致的性能。

